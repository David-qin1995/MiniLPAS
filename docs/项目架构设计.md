# MiniLPAS 项目架构设计文档

## 一、整体架构

### 1.1 系统分层架构

MiniLPAS 采用经典的三层架构设计：

```
┌─────────────────────────────────────────────────────────────┐
│                    表示层 (Presentation)                      │
│  Web Frontend (React + TypeScript)                          │
│  - 用户界面                                                 │
│  - 用户交互                                                 │
│  - 状态管理                                                 │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        │ HTTP/WebSocket
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                    业务层 (Business)                         │
│  Web Backend (Spring Boot + Kotlin)                         │
│  - REST API                                                 │
│  - WebSocket Server                                         │
│  - 业务逻辑处理                                             │
│  - 会话管理                                                 │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        │ WebSocket
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                    数据访问层 (Data Access)                  │
│  Local Agent (Kotlin + PCSC + LPAC)                         │
│  - 硬件设备访问                                             │
│  - LPAC 命令执行                                            │
│  - 数据转换                                                 │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        │ PCSC Protocol
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                    硬件层 (Hardware)                         │
│  eSIM 设备 / 智能卡读取器                                    │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 通信架构

#### HTTP REST API
- **用途**：同步数据请求和响应
- **协议**：HTTP/1.1 或 HTTP/2
- **数据格式**：JSON
- **认证**：Bearer Token（如需要）

#### WebSocket
- **用途**：实时双向通信
- **协议**：WebSocket over TCP
- **数据格式**：JSON
- **用途**：
  - 前端实时状态更新
  - 本地代理与后端通信
  - 命令执行和响应

## 二、组件设计

### 2.1 前端组件架构

#### 组件层次结构

```
App
├── Layout
│   ├── Header
│   ├── Navigation
│   └── Footer
├── DeviceStatus          # 设备连接状态
├── ChipInfo             # 芯片信息
├── ProfileList          # 配置文件列表
│   └── ProfileCard      # 配置文件卡片
├── NotificationList     # 通知列表
│   └── NotificationCard # 通知卡片
└── DownloadProfile      # 下载配置文件
    └── DropArea         # 拖拽上传区域
```

#### 组件设计原则

1. **单一职责**：每个组件只负责一个功能
2. **可复用性**：通用组件可在多处使用
3. **可组合性**：小组件组合成复杂组件
4. **状态提升**：共享状态提升到共同父组件

### 2.2 后端模块架构

```
web-backend/
├── config/              # 配置类
│   ├── WebSocketConfig
│   └── CorsConfig
├── controller/          # REST 控制器
│   ├── DeviceController
│   ├── ChipController
│   ├── ProfileController
│   └── NotificationController
├── service/             # 业务服务
│   ├── AgentConnectionService
│   └── ProfileService
├── websocket/           # WebSocket 处理
│   ├── AgentWebSocketHandler
│   └── FrontendWebSocketHandler
└── model/               # 数据模型
    ├── Device
    ├── Profile
    └── Notification
```

### 2.3 本地代理架构

```
local-agent/
├── client/              # WebSocket 客户端
│   └── BackendClient
├── handler/             # 命令处理
│   └── CommandHandler
├── executor/            # LPAC 执行器
│   └── LPACExecutor
└── model/               # 数据模型
    ├── Command
    └── Response
```

## 三、数据流设计

### 3.1 配置文件列表获取流程

```
前端
  │
  ├─1. GET /api/profiles──────┐
  │                           │
  ├─2. 显示加载状态           │
  │                           ▼
  └─3. 渲染配置文件列表     后端
                               │
                               ├─1. 检查代理连接
                               │
                               ├─2. 发送 WebSocket 命令────────┐
                               │                               │
                               ├─3. 等待响应                  │
                               │                               ▼
                               └─4. 返回数据                 代理
                                                               │
                                                               ├─1. 执行 LPAC 命令
                                                               │
                                                               ├─2. 读取设备数据
                                                               │
                                                               └─3. 返回结果
```

### 3.2 实时状态更新流程

```
设备状态变化
    │
    ▼
代理检测变化
    │
    ▼
 Create WebSocket 消息
    │
    ▼
后端接收并广播
    │
    ▼
前端 WebSocket 接收
    │
    ▼
更新 UI 状态
```

## 四、关键设计模式

### 4.1 观察者模式

- **前端**：React 状态更新触发 UI 重渲染
- **WebSocket**：事件驱动的消息处理

### 4.2 策略模式

- **命令处理**：不同的 LPAC 命令使用不同的处理策略
- **搜索**：不同的搜索策略（普通、正则、整词）

### 4.3 工厂模式

- **组件创建**：React 组件工厂
- **消息创建**：WebSocket 消息工厂

### 4.4 单例模式

- **连接管理**：AgentConnectionService 单例
- **配置管理**：全局配置单例

## 五、安全设计

### 5.1 通信安全

1. **HTTPS/WSS**：生产环境使用加密连接
2. **CORS 配置**：限制跨域访问
3. **输入验证**：前后端双重验证

### 5.2 认证授权（如需要）

1. **JWT Token**：无状态认证
2. **角色权限**：基于角色的访问控制

### 5.3 数据安全

1. **敏感数据加密**：传输和存储加密
2. **日志脱敏**：日志中不包含敏感信息

## 六、性能优化设计

### 6.1 前端优化

1. **代码分割**：按路由懒加载
2. **虚拟列表**：大量数据使用虚拟滚动
3. **防抖节流**：搜索和滚动事件优化
4. **缓存策略**：API 响应缓存

### 6.2 后端优化

1. **连接池**：WebSocket 连接池管理
2. **异步处理**：长时间操作异步化
3. **缓存机制**：热点数据缓存

### 6.3 WebSocket 优化

1. **心跳机制**：保持连接活跃
2. **消息队列**：避免消息丢失
3. **批量更新**：合并多个更新

## 七、可扩展性设计

### 7.1 水平扩展

1. **无状态设计**：后端服务无状态，易于扩展
2. **负载均衡**：支持多实例部署
3. **共享存储**：状态存储到共享服务（如需要）

### 7.2 功能扩展

1. **插件机制**：支持功能插件（如需要）
2. **API 版本**：API 版本控制
3. **模块化设计**：易于添加新模块

## 八、监控与运维

### 8.1 日志设计

1. **结构化日志**：JSON 格式日志
2. **日志级别**：DEBUG、INFO、WARN、ERROR
3. **日志聚合**：集中式日志收集

### 8.2 监控指标

1. **性能指标**：响应时间、吞吐量
2. **业务指标**：操作成功率、错误率
3. **系统指标**：CPU、内存、连接数

### 8.3 健康检查

1. **健康检查端点**：`/actuator/health`
2. **依赖检查**：检查数据库、外部服务连接

## 九、总结

本架构设计遵循以下原则：

1. **分层清晰**：职责明确，易于维护
2. **松耦合**：组件之间依赖最小化
3. **高内聚**：相关功能集中管理
4. **可扩展**：易于添加新功能
5. **可维护**：代码清晰，文档完善
6. **高性能**：优化关键路径
7. **安全可靠**：考虑安全性数据

---

**文档版本**：v1.0  
**最后更新**：2025-10-30



